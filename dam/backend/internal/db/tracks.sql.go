// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tracks.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const bulkUpdateTracksSong = `-- name: BulkUpdateTracksSong :exec
UPDATE tracks SET song_id = ? WHERE id IN (/*SLICE:ids*/?)
`

type BulkUpdateTracksSongParams struct {
	SongID sql.NullString `json:"song_id"`
	Ids    []string       `json:"ids"`
}

func (q *Queries) BulkUpdateTracksSong(ctx context.Context, arg BulkUpdateTracksSongParams) error {
	query := bulkUpdateTracksSong
	var queryParams []interface{}
	queryParams = append(queryParams, arg.SongID)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const createTrack = `-- name: CreateTrack :one
INSERT INTO tracks (
    id, song_id, source_type, file_path, suno_id, udio_id, image_path,
    title, duration_ms, style_desc, rating, is_trash, is_deleted,
    artist_tags, album_tags, genre_tags, mood_tags, tags, metadata
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at
`

type CreateTrackParams struct {
	ID         string         `json:"id"`
	SongID     sql.NullString `json:"song_id"`
	SourceType string         `json:"source_type"`
	FilePath   string         `json:"file_path"`
	SunoID     sql.NullString `json:"suno_id"`
	UdioID     sql.NullString `json:"udio_id"`
	ImagePath  sql.NullString `json:"image_path"`
	Title      string         `json:"title"`
	DurationMs sql.NullInt64  `json:"duration_ms"`
	StyleDesc  sql.NullString `json:"style_desc"`
	Rating     sql.NullInt64  `json:"rating"`
	IsTrash    bool           `json:"is_trash"`
	IsDeleted  bool           `json:"is_deleted"`
	ArtistTags sql.NullString `json:"artist_tags"`
	AlbumTags  sql.NullString `json:"album_tags"`
	GenreTags  sql.NullString `json:"genre_tags"`
	MoodTags   sql.NullString `json:"mood_tags"`
	Tags       sql.NullString `json:"tags"`
	Metadata   sql.NullString `json:"metadata"`
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, createTrack,
		arg.ID,
		arg.SongID,
		arg.SourceType,
		arg.FilePath,
		arg.SunoID,
		arg.UdioID,
		arg.ImagePath,
		arg.Title,
		arg.DurationMs,
		arg.StyleDesc,
		arg.Rating,
		arg.IsTrash,
		arg.IsDeleted,
		arg.ArtistTags,
		arg.AlbumTags,
		arg.GenreTags,
		arg.MoodTags,
		arg.Tags,
		arg.Metadata,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllTracks = `-- name: DeleteAllTracks :exec
DELETE FROM tracks
`

func (q *Queries) DeleteAllTracks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllTracks)
	return err
}

const deleteTrack = `-- name: DeleteTrack :exec
DELETE FROM tracks WHERE id = ?
`

func (q *Queries) DeleteTrack(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTrack, id)
	return err
}

const getTrack = `-- name: GetTrack :one
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks WHERE id = ? LIMIT 1
`

func (q *Queries) GetTrack(ctx context.Context, id string) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrack, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTrackByFilePath = `-- name: GetTrackByFilePath :one
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks WHERE file_path = ? LIMIT 1
`

func (q *Queries) GetTrackByFilePath(ctx context.Context, filePath string) (Track, error) {
	row := q.db.QueryRowContext(ctx, getTrackByFilePath, filePath)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSunoTracksInFolder = `-- name: ListSunoTracksInFolder :many

SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE source_type = 'suno'
  AND file_path LIKE ?
  AND is_deleted = 0
ORDER BY created_at DESC
`

// WORKSPACE QUERIES (file path based)
func (q *Queries) ListSunoTracksInFolder(ctx context.Context, filePath string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listSunoTracksInFolder, filePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracks = `-- name: ListTracks :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksByRating = `-- name: ListTracksByRating :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE rating = ? AND is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListTracksByRating(ctx context.Context, rating sql.NullInt64) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksByRating, rating)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksBySong = `-- name: ListTracksBySong :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks WHERE song_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListTracksBySong(ctx context.Context, songID sql.NullString) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksBySong, songID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTracksBySource = `-- name: ListTracksBySource :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE source_type = ? AND is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListTracksBySource(ctx context.Context, sourceType string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTracksBySource, sourceType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrashedTracks = `-- name: ListTrashedTracks :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE is_trash = 1 AND is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListTrashedTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listTrashedTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUdioTracksInPath = `-- name: ListUdioTracksInPath :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE source_type = 'udio'
  AND file_path LIKE ?
  AND is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListUdioTracksInPath(ctx context.Context, filePath string) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listUdioTracksInPath, filePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedTracks = `-- name: ListUnassignedTracks :many
SELECT id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at FROM tracks
WHERE song_id IS NULL AND is_deleted = 0
ORDER BY created_at DESC
`

func (q *Queries) ListUnassignedTracks(ctx context.Context) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.SongID,
			&i.SourceType,
			&i.FilePath,
			&i.SunoID,
			&i.UdioID,
			&i.ImagePath,
			&i.Title,
			&i.DurationMs,
			&i.StyleDesc,
			&i.Rating,
			&i.IsTrash,
			&i.IsDeleted,
			&i.ArtistTags,
			&i.AlbumTags,
			&i.GenreTags,
			&i.MoodTags,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTrack = `-- name: SoftDeleteTrack :exec
UPDATE tracks SET is_deleted = 1 WHERE id = ?
`

func (q *Queries) SoftDeleteTrack(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, softDeleteTrack, id)
	return err
}

const updateTrack = `-- name: UpdateTrack :one
UPDATE tracks
SET
  song_id = COALESCE(?1, song_id),
  title = COALESCE(?2, title),
  duration_ms = COALESCE(?3, duration_ms),
  rating = COALESCE(?4, rating),
  is_trash = COALESCE(?5, is_trash),
  style_desc = COALESCE(?6, style_desc),
  artist_tags = COALESCE(?7, artist_tags),
  album_tags = COALESCE(?8, album_tags),
  genre_tags = COALESCE(?9, genre_tags),
  mood_tags = COALESCE(?10, mood_tags),
  tags = COALESCE(?11, tags),
  metadata = COALESCE(?12, metadata)
WHERE id = ?13
RETURNING id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at
`

type UpdateTrackParams struct {
	SongID     sql.NullString `json:"song_id"`
	Title      sql.NullString `json:"title"`
	DurationMs sql.NullInt64  `json:"duration_ms"`
	Rating     sql.NullInt64  `json:"rating"`
	IsTrash    sql.NullBool   `json:"is_trash"`
	StyleDesc  sql.NullString `json:"style_desc"`
	ArtistTags sql.NullString `json:"artist_tags"`
	AlbumTags  sql.NullString `json:"album_tags"`
	GenreTags  sql.NullString `json:"genre_tags"`
	MoodTags   sql.NullString `json:"mood_tags"`
	Tags       sql.NullString `json:"tags"`
	Metadata   sql.NullString `json:"metadata"`
	ID         string         `json:"id"`
}

func (q *Queries) UpdateTrack(ctx context.Context, arg UpdateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrack,
		arg.SongID,
		arg.Title,
		arg.DurationMs,
		arg.Rating,
		arg.IsTrash,
		arg.StyleDesc,
		arg.ArtistTags,
		arg.AlbumTags,
		arg.GenreTags,
		arg.MoodTags,
		arg.Tags,
		arg.Metadata,
		arg.ID,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTrackRating = `-- name: UpdateTrackRating :one
UPDATE tracks SET rating = ? WHERE id = ? RETURNING id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at
`

type UpdateTrackRatingParams struct {
	Rating sql.NullInt64 `json:"rating"`
	ID     string        `json:"id"`
}

func (q *Queries) UpdateTrackRating(ctx context.Context, arg UpdateTrackRatingParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackRating, arg.Rating, arg.ID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTrackSong = `-- name: UpdateTrackSong :one
UPDATE tracks SET song_id = ? WHERE id = ? RETURNING id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at
`

type UpdateTrackSongParams struct {
	SongID sql.NullString `json:"song_id"`
	ID     string         `json:"id"`
}

func (q *Queries) UpdateTrackSong(ctx context.Context, arg UpdateTrackSongParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackSong, arg.SongID, arg.ID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTrackTrash = `-- name: UpdateTrackTrash :one
UPDATE tracks SET is_trash = ? WHERE id = ? RETURNING id, song_id, source_type, file_path, suno_id, udio_id, image_path, title, duration_ms, style_desc, rating, is_trash, is_deleted, artist_tags, album_tags, genre_tags, mood_tags, tags, metadata, created_at, updated_at
`

type UpdateTrackTrashParams struct {
	IsTrash bool   `json:"is_trash"`
	ID      string `json:"id"`
}

func (q *Queries) UpdateTrackTrash(ctx context.Context, arg UpdateTrackTrashParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, updateTrackTrash, arg.IsTrash, arg.ID)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.SongID,
		&i.SourceType,
		&i.FilePath,
		&i.SunoID,
		&i.UdioID,
		&i.ImagePath,
		&i.Title,
		&i.DurationMs,
		&i.StyleDesc,
		&i.Rating,
		&i.IsTrash,
		&i.IsDeleted,
		&i.ArtistTags,
		&i.AlbumTags,
		&i.GenreTags,
		&i.MoodTags,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
